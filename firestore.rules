rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function cleanPath(path) {
      return path.split('/').join('_');
    }
    
    // All collection rules
    match /termsOfUseAcceptance/{document} {
      // Allow get (single document) if user owns it
      allow get: if request.auth != null &&
                    request.auth.uid == resource.data.userId;
      // Allow list/query if user is authenticated (queries are filtered by userId in code)
      allow list: if request.auth != null;
      allow create: if request.auth != null &&
                     request.auth.uid == request.resource.data.userId &&
                     request.resource.data.accepted == true;
    }
	
	match /online/{onlineId} {
 	 allow read: if request.auth.uid != null;
  	allow write: if request.auth.uid != null;
	}

    match /councils/{councilId=**} {
      allow read;
      allow write: if request.auth.uid != null;
    }

    match /version/{version=**} {
      allow read;
    }

	match /polarizationIndex/{statementId=**} {
	  allow read: if request.auth.uid != null;
	
	}

	match /userDemographic/{userId=**} {
	  allow read: if request.auth.uid != null && request.auth.uid == userId;
	  allow write: if request.auth.uid != null && request.auth.uid == userId;
	}

  match /fairDivision/{userId=**} {
	  allow read: if request.auth.uid != null && request.auth.uid == userId;
	  allow write: if request.auth.uid != null && request.auth.uid == userId;
	}

	match /userDemographicQuestions/{questionId=**} {
		function isAdmin() {
			let question = resource != null ? resource : request.resource;
			let statementId = question.data.statementId;
			let subId = string(request.auth.uid) + '--' + cleanPath(string(statementId));
			let subscription = get(/databases/$(database)/documents/statementsSubscribe/$(subId)).data;
			return subscription != null && subscription.role == 'admin';
		}
		
		allow read: if request.auth.uid != null;
		allow write: if request.auth.uid != null && isAdmin();
	}

    match /statements/{statementId} {
      function isAdmin() {
        let subId = string(request.auth.uid) + '--' + cleanPath(string(statementId));
        let subscription = get(/databases/$(database)/documents/statementsSubscribe/$(subId)).data;
        return subscription != null && subscription.role == 'admin';
      }
      
      function isCreator() {
        return request.auth.uid != null && resource.data.creatorId == request.auth.uid;
      }
      
      function hasProtectedFieldChanges() {
        return resource != null && request.resource != null && (
          // Check if questionSettings is being modified
          (request.resource.data.questionSettings != resource.data.questionSettings) ||
          // Check if statementSettings is being modified
          (request.resource.data.statementSettings != resource.data.statementSettings)
        );
      }
      
      // Only allow membership.access to be changed by admins or creator
      function hasUnauthorizedAccessChange() {
        return resource != null && request.resource != null &&
               request.resource.data.membership.access != resource.data.membership.access &&
               !(isAdmin() || isCreator());
      }
      
      function isAllowedToUpdate() {
        return !hasProtectedFieldChanges() && !hasUnauthorizedAccessChange() || 
               (isAdmin() || isCreator());
      }
      
      allow read;
      allow create: if request.auth.uid != null;
      allow update: if request.auth.uid != null && isAllowedToUpdate();
      allow delete: if request.auth.uid != null && (isAdmin() || isCreator());
    }

    match /inAppNotifications/{inAppNotificationId=**} {
      // Allow read if authenticated - the app already filters by userId in queries
      allow read: if request.auth.uid != null;
      // Only allow updates and deletes by the owner of the notification
      allow update: if request.auth.uid == resource.data.userId;
      allow delete: if request.auth.uid == resource.data.userId;
    }

    match /pushNotifications/{pushNotificationId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /askedToBeNotified/{askedToBeNotifiedId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /statementsMeta/{statementId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /importance/{importanceId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /statementViews/{statementId=**} {
      allow write: if request.auth.uid != null;
      allow read: if request.auth.uid != null;
    }

    match /statementSegments/{segementId=**} {
      allow write: if request.auth.uid != null;
      allow read: if request.auth.uid != null;
    }

    match /approval/{approvalId=**} {
      allow read;
      allow write: if request.auth.uid != null;
    }
    
    match /documentsSigns/{documentsSignId=**} {
      allow read: if request.auth.uid != null;
    }
    
    match /signatures/{signaturesId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }
    
    match /agrees/{agreeId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }
    
    match /invitations/{invitationId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }
    
    match /admins/{adminStatementId=**} {
      allow write: if request.auth.uid == request.resource.data.user.uid;
    }
    
   match /statementsSubscribe/{statementSubId} {
      // Simple getter functions
      function isSubscriber() {
        return request.auth.uid != null && resource.data.userId == request.auth.uid;
      }
      
      function getStatementId() {
        return resource != null ? resource.data.statementId : request.resource.data.statementId;
      }
      
      function isAdmin() {
        let statementId = getStatementId();
        let subId = string(request.auth.uid) + '--' + cleanPath(string(statementId));
        let subscription = get(/databases/$(database)/documents/statementsSubscribe/$(subId)).data;
        return subscription != null && subscription.role == 'admin';
      }
      
      function isCreator() {
        let statementId = getStatementId();
        let statement = get(/databases/$(database)/documents/statements/$(statementId)).data;
        return statement != null && statement.creatorId == request.auth.uid;
      }
      
      function isAdminOrCreator() {
        return isAdmin() || isCreator();
      }
      
      function getAccess() {
        let statementId = getStatementId();
        let statement = get(/databases/$(database)/documents/statements/$(statementId)).data;
        
        // Check for statement's own access override first, then topParent's access
        return statement != null && statement.membership != null && statement.membership.access != null 
          ? statement.membership.access 
          : (statement != null && statement.topParentId != null 
            ? (get(/databases/$(database)/documents/statements/$(statement.topParentId)).data != null &&
               get(/databases/$(database)/documents/statements/$(statement.topParentId)).data.membership != null &&
               get(/databases/$(database)/documents/statements/$(statement.topParentId)).data.membership.access != null
                 ? get(/databases/$(database)/documents/statements/$(statement.topParentId)).data.membership.access
                 : null)
            : null);
      }
      
      function isBanned() {
        return resource != null && resource.data.role == "banned";
      }
      
      function isOpenToAll() {
        return getAccess() == "openToAll";
      }
      
      function isOpenForRegistered() {
        return getAccess() == "openForRegistered";
      }
      
      function isModerated() {
        return getAccess() == "moderated";
      }
      
      function isPublic() {
        return getAccess() == "public";
      }
      
      function isWaitingRole() {
        return request.resource.data.role == "waiting";
      }
      
      function isMemberRole() {
        return request.resource.data.role == "member";
      }
      
      function isRoleUnchanged() {
        return request.resource.data.role == resource.data.role;
      }

      function isTargetAdmin() {
        // Check if the target subscription (being updated) has admin or creator role
        return resource != null && (resource.data.role == "admin" || resource.data.role == "statement-creator");
      }

      function isTargetStatementCreator() {
        // Check if the target user is the statement creator
        let statementId = getStatementId();
        let statement = get(/databases/$(database)/documents/statements/$(statementId)).data;
        return resource != null && statement != null && statement.creatorId == resource.data.userId;
      }

      function isTryingToBanProtectedUser() {
        // Prevent changing admin/creator roles to banned
        return request.resource.data.role == "banned" &&
               resource.data.role != "banned" &&
               (isTargetAdmin() || isTargetStatementCreator());
      }

      allow read: if request.auth.uid != null;

      // For create
      allow create: if request.auth.uid != null &&
                     (isPublic() ||
                      isOpenToAll() ||
                      isOpenForRegistered() ||
                      (isModerated() && isWaitingRole()));

      // For update
      allow update: if request.auth.uid != null &&
                     !isTryingToBanProtectedUser() &&
                     (isAdminOrCreator() ||
                      (isSubscriber() &&
                        (isRoleUnchanged() ||
                          (!isBanned() &&
                            ((isModerated() && isWaitingRole()) ||
                             ((isPublic() || isOpenToAll() || isOpenForRegistered()) && isMemberRole())))
                        )
                      ));
      
      // For delete
      allow delete: if request.auth.uid != null && 
                     (isAdminOrCreator() ||
                      (isSubscriber() && !isBanned()));
    }

    // The rest of the collection rules...
    match /massConsensusProcesses/{statementId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }
    
    match /statementsSignatures/{signatureId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /massConsensusMembers/{userId=**} {
      allow write: if request.auth.uid != null;
    }

    match /choseBy/{statementId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /statementRoomsAsked/{requestId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /resultsTriggers/{statementId=**} {
      allow write: if request.auth.uid != null;
    }

    match /statementLobbyRooms/{statementId=**} {
      allow read: if request.auth.uid != null;
    }

    match /awaitingUsers/{documentId} {
      // User can read/delete if they are in the adminIds array of the document
      function isAdminForDocument() {
        return resource.data.adminIds != null &&
               request.auth.uid in resource.data.adminIds;
      }

      allow read: if request.auth != null && isAdminForDocument();
      allow delete: if request.auth != null && isAdminForDocument();
      allow create, update: if false;
    }

    match /timers-settings/{timerIdx=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }
    
    match /rooms/{roomId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }
    
    match /participants/{participantId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }
    
    match /roomsSettings/{roomSettingsId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /roomParticipants/{participantId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /timers-rooms/{timerIdx=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /evaluations/{evluationId=**} {
      allow read: if true; // Allow public read for mass consensus
      allow create: if request.resource.data.keys().hasAll(['evaluationId', 'parentId', 'statementId', 'evaluatorId', 'evaluation', 'updatedAt'])
                    && request.resource.data.evaluationId is string
                    && request.resource.data.parentId is string
                    && request.resource.data.statementId is string
                    && request.resource.data.evaluatorId is string
                    && request.resource.data.evaluation is number
                    && request.resource.data.updatedAt is number;
      allow update: if request.resource.data.keys().hasAll(['evaluationId', 'parentId', 'statementId', 'evaluatorId', 'evaluation', 'updatedAt'])
                    && request.resource.data.evaluationId is string
                    && request.resource.data.parentId is string
                    && request.resource.data.statementId is string
                    && request.resource.data.evaluatorId is string
                    && request.resource.data.evaluation is number
                    && request.resource.data.updatedAt is number;
      allow delete: if request.auth.uid != null; // Only authenticated users can delete
    }

    // Typing status for real-time collaboration indicators
    match /typingStatus/{typingId} {
      // Anyone authenticated can read typing status
      // DEBUG: Allow public read to investigate permission error
      allow read: if true;
      // Users can only write their own typing status (document ID includes their userId)
      allow create, update: if request.auth != null &&
                              request.resource.data.userId == request.auth.uid;
      // Users can delete their own typing status
      // Note: resource may be null if document doesn't exist, so we check for it first
      allow delete: if request.auth != null &&
                      (resource == null || resource.data.userId == request.auth.uid);
    }

    // Suggestions for document paragraphs (Sign app)
    match /suggestions/{suggestionId} {
      // Anyone authenticated can read suggestions
      // DEBUG: Allow public read to investigate permission error
      allow read: if true;
      // Users can create suggestions
      allow create: if request.auth != null &&
                      request.resource.data.creatorId == request.auth.uid;
      // Users can only update/delete their own suggestions
      allow update, delete: if request.auth != null &&
                              resource.data.creatorId == request.auth.uid;
    }

    match /userEvaluations/{documentId} {
      // Users can read their own evaluation tracking or if they're an anonymous user
      allow read: if request.auth != null ||
        (resource != null && resource.data.userId != null);

      // Users can create their own evaluation tracking document
      allow create: if request.auth != null ||
        (request.resource.data.userId != null &&
         request.resource.data.parentStatementId != null);

      // Users can update their own evaluation tracking
      // For anonymous users, check that the userId matches what's in the document
      allow update: if request.auth != null ||
        (resource != null &&
         resource.data.userId == request.resource.data.userId);

      // Prevent deletion to maintain history
      allow delete: if false;
    }

    match /approval/{approvalId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /statementEvaluators/{statementEvaluatorsId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /votes/{voteId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }
    
    match /posts/{postId=**} {
      allow read;
      allow write: if request.auth.uid != null;
    }
    
    match /chatMessages/{chatMessageId} {
      allow read;
      allow write: if request.auth.uid != null;
    }
    
    match /groups/{group=**} {
      allow read;
      allow write: if request.auth.uid != null;
    }
    
    match /chats/{chatId} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid == resource.data.creator.uid;
    }

    match /usersSettings/{userId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /usersData/{userId=**} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid != null;
    }

    match /usersV2/{userId} {
      allow read: if request.auth != null;
      // Allow users to write their own document (userId must match auth uid)
      allow write: if request.auth != null && request.auth.uid == userId;

      // Subcollections - user can only access their own subcollections
      match /chat/{chat=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /chatLastEnterence/{chatLastEnterence=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /feed/{feed=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /feedLastEntrence/{feedLastEntrence=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /feeds/{feeds=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /groups/{groups=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /groupsOwned/{groupsOwned=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /messages/{messages=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /messagesCounter/{messagesCounter=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /optionsRead/{optionsRead=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /registerGroups/{registerGroups=**} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      match /memberships/{membership} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    match /messages/{message=**} {
      allow read;
      allow write: if request.auth.uid != null;
    }
    
    match /tokens/{token=**} {
      allow read;
      allow write: if request.auth.uid != null;
    }
      
    match /consultations/{consultationId} {
      function isPublic() {
        return resource.data.groupType == 'public';
      }
      
      function hasMembershipRole() {
        let membershipDoc = get(/databases/$(database)/documents/users/$(request.auth.uid)/memberships/$(consultationId)).data;
        return membershipDoc != null && membershipDoc.role != null;
      }
      
      function isConsultationCreator() {
        let consultation = get(/databases/$(database)/documents/consultations/$(consultationId)).data;
        return consultation != null && consultation.creator.uid == request.auth.uid;
      }
      
      allow read: if isPublic() || hasMembershipRole();
      allow write: if request.auth.uid == request.resource.data.creator.uid;
      
      match /meta/{metaId} {
        allow read: if request.auth.uid != null;
        allow write: if isConsultationCreator();
      }
    }
    
    match /news/{new} {
      allow read: if request.auth.uid != null;
      allow write: if request.auth.uid == request.resource.data.creator.uid;
    }

    // Feedback collection rules
    match /feedback/{feedbackId} {
      // Only authenticated users can create feedback
      allow create: if request.auth != null &&
                      request.resource.data.creator != null &&
                      request.resource.data.creator.uid == request.auth.uid &&
                      request.resource.data.feedbackText != null &&
                      request.resource.data.feedbackText != "";

      // Allow read for authenticated users
      // In production, you may want to restrict this further
      allow read: if request.auth != null;

      // Feedback cannot be updated or deleted once submitted
      allow update, delete: if false;
    }

    // Member validation status collection rules
    match /memberValidationStatuses/{validationId} {
      function isStatementAdmin() {
        let validation = resource != null ? resource : request.resource;
        let statementId = validation.data.statementId;
        let subId = string(request.auth.uid) + '--' + cleanPath(string(statementId));
        let subscription = get(/databases/$(database)/documents/statementsSubscribe/$(subId)).data;
        return subscription != null && subscription.role == 'admin';
      }

      function isStatementCreator() {
        let validation = resource != null ? resource : request.resource;
        let statementId = validation.data.statementId;
        let statement = get(/databases/$(database)/documents/statements/$(statementId)).data;
        return statement != null && statement.creatorId == request.auth.uid;
      }

      // Allow read for authenticated users (needed to check member statuses)
      allow read: if request.auth != null;

      // Only allow create/update/delete for statement admins or creators
      allow create, update: if request.auth != null && (isStatementAdmin() || isStatementCreator());
      allow delete: if request.auth != null && (isStatementAdmin() || isStatementCreator());
    }

    // Popper-Hebbian Discussion System Rules

    // Refinement Sessions - Users can only access their own sessions
    match /refinementSessions/{sessionId} {
      allow read: if request.auth != null &&
                    resource.data.userId == request.auth.uid;
      allow create: if request.auth != null &&
                      request.resource.data.userId == request.auth.uid;
      allow update: if request.auth != null &&
                      resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null &&
                      resource.data.userId == request.auth.uid;
    }

    // Evidence Votes - Users can manage their own votes
    match /evidenceVotes/{voteId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null &&
                      request.resource.data.userId == request.auth.uid;
      allow update: if request.auth != null &&
                      resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null &&
                      resource.data.userId == request.auth.uid;
    }

    // Email Subscribers - for mass consensus email notifications
    // Note: This collection is primarily written by Firebase Admin SDK (server-side)
    // but we allow public creation for anonymous email subscriptions
    match /emailSubscribers/{subscriberId} {
      function isStatementAdmin() {
        let subscriber = resource != null ? resource : request.resource;
        let statementId = subscriber.data.statementId;
        let subId = string(request.auth.uid) + '--' + cleanPath(string(statementId));
        let subscription = get(/databases/$(database)/documents/statementsSubscribe/$(subId)).data;
        return subscription != null && (subscription.role == 'admin' || subscription.role == 'statement-creator');
      }

      // Allow creation with valid email and statementId (for public subscription)
      // Most writes happen through Firebase Admin SDK which bypasses rules
      allow create: if request.resource.data.email != null &&
                      request.resource.data.statementId != null &&
                      request.resource.data.isActive == true;

      // Allow reading for admins of the statement
      allow read: if request.auth != null && isStatementAdmin();

      // Allow users to update their own subscription (e.g., unsubscribe)
      allow update: if request.auth != null &&
                      (resource.data.userId == request.auth.uid || isStatementAdmin());

      // Allow admins to delete subscriptions
      allow delete: if request.auth != null && isStatementAdmin();
    }

    // Result Subscriptions - legacy collection for backwards compatibility
    match /resultSubscriptions/{subscriptionId} {
      allow create: if request.resource.data.email != null &&
                      request.resource.data.statementId != null;
      allow read: if request.auth != null;
      allow update, delete: if false;
    }

    // Room Assignment Rules are defined above in the simple rules section
    // (rooms, roomsSettings, roomParticipants at lines 343-356)
    // Cloud functions handle authorization for writes

    // Version Control - Paragraph Replacement Queue
    match /paragraphReplacementQueue/{queueId} {
      // Allow read for authenticated users
      // Note: AuthSync uses anonymous login, so request.auth.uid is NOT the real userId
      // Admin verification is done server-side when processing actions (approve/reject)
      // The client query filters by documentId, so users only see queue items for documents they access
      allow read: if request.auth != null;

      // Writes handled by Cloud Functions only
      allow write: if false;
    }

    // Version Control - Audit Trail
    match /versionControlAudit/{auditId} {
      // Allow queries for authenticated users
      // AuthSync component ensures Firebase Auth is initialized on client
      allow list: if request.auth != null;

      // For single document reads, verify admin access
      allow get: if request.auth != null &&
                    resource.data.documentId != null &&
                    exists(/databases/$(database)/documents/statementsSubscribe/$(request.auth.uid + '--' + cleanPath(resource.data.documentId))) &&
                    get(/databases/$(database)/documents/statementsSubscribe/$(request.auth.uid + '--' + cleanPath(resource.data.documentId))).data.role == 'admin';

      // Writes handled by Cloud Functions only
      allow write: if false;
    }
  }
}