import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { initializeApp } from 'firebase/app';
import { getMessaging, onBackgroundMessage } from 'firebase/messaging/sw';

// ==========================================
// Workbox Pre-caching & Routing
// ==========================================

// Clean up old service worker cache entries
cleanupOutdatedCaches();

// Precache all assets generated by the build system
precacheAndRoute(self.__WB_MANIFEST || []);

// Handle HTML files - always prefer network for the latest version
registerRoute(
  ({ request }) => request.destination === 'document',
  new NetworkFirst({
    cacheName: 'html-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60, // 1 minute
      }),
    ],
  })
);

// Handle JavaScript and CSS assets
registerRoute(
  ({ request, url }) =>
    (request.destination === 'script' || request.destination === 'style') &&
    url.origin === self.location.origin,
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  })
);

// Handle images
registerRoute(
  ({ request, url }) =>
    request.destination === 'image' &&
    url.origin === self.location.origin,
  new CacheFirst({
    cacheName: 'image-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Firebase API calls
registerRoute(
  ({ url }) => 
    url.href.includes('firestore.googleapis.com') || 
    url.href.includes('firebase'),
  new NetworkFirst({
    cacheName: 'firebase-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 5, // 5 minutes
      }),
    ],
    networkTimeoutSeconds: 10,
  })
);

// ==========================================
// Firebase Messaging
// ==========================================

// Determine correct config based on domain
const currentDomain = self.location.hostname;
let firebaseConfig;

if (currentDomain === 'freedi.tech' || currentDomain === 'delib.web.app' || currentDomain === 'localhost' || currentDomain === '127.0.0.1') {
	// Development / Main config
	firebaseConfig = {
		apiKey: "AIzaSyBEumZUTCL3Jc9pt7_CjiSVTxmz9aMqSvo",
		authDomain: "synthesistalyaron.firebaseapp.com",
		databaseURL: "https://synthesistalyaron.firebaseio.com",
		projectId: "synthesistalyaron",
		storageBucket: "synthesistalyaron.appspot.com",
		messagingSenderId: "799655218679",
		appId: "1:799655218679:web:1409dd5e3b4154ecb9b2f2",
		measurementId: "G-XSGFFBXM9X",
	};
} else if (currentDomain === 'freedi-test.web.app') {
	// Freedi Test config
	firebaseConfig = {
		apiKey: 'AIzaSyBCgq3y9WjS8ZkB-q_lnkFM2BuUdLp2M-g',
		authDomain: 'freedi-test.firebaseapp.com',
		projectId: 'freedi-test',
		storageBucket: 'freedi-test.firebasestorage.app',
		messagingSenderId: '47037334917',
		appId: '1:47037334917:web:f9bce2dd772b5efd29f0ec'
	};
} else if (currentDomain === 'wizcol-app.web.app') {
	// Wizcol Production config
	firebaseConfig = {
		apiKey: 'AIzaSyBtm5USTMMQqf9KQ3ZIne6VbZ6AGOiT-Ts',
		authDomain: 'wizcol-app.firebaseapp.com',
		projectId: 'wizcol-app',
		storageBucket: 'wizcol-app.firebasestorage.app',
		messagingSenderId: '337833396726',
		appId: '1:337833396726:web:b80268707145886ce95fd7'
	};
} else {
	// Fallback
	console.warn('Using fallback config for unknown domain:', currentDomain);
	firebaseConfig = {
		apiKey: 'AIzaSyBCgq3y9WjS8ZkB-q_lnkFM2BuUdLp2M-g',
		authDomain: 'freedi-test.firebaseapp.com',
		projectId: 'freedi-test',
		storageBucket: 'freedi-test.firebasestorage.app',
		messagingSenderId: '47037334917',
		appId: '1:47037334917:web:f9bce2dd772b5efd29f0ec'
	};
}

try {
  const app = initializeApp(firebaseConfig);
  const messaging = getMessaging(app);

  // Background message handler
  onBackgroundMessage(messaging, async (payload) => {
    console.log('[firebase-sw] Received background message ', payload);

    if (!payload.notification) {
      return;
    }

    const { title, body, image } = payload.notification;
    const data = payload.data || {};
    const notificationId = data.id || Date.now().toString();
    const url = data.url || '/';

    // Store in cache for click handling
    await saveNotificationToCache(notificationId, { ...payload, timestamp: Date.now() });

    // Handle Badges
    await incrementBadgeCount();

    const notificationOptions = {
      body: body || '',
      icon: '/icons/logo-192px.png',
      badge: '/icons/logo-48px.png',
      image: image || '',
      vibrate: [100, 50, 100, 50, 100],
      tag: data.tag || notificationId,
      data: { ...data, notificationId, url },
      actions: [{ action: 'open', title: data.openActionTitle || 'Open' }],
      requireInteraction: data.requireInteraction !== 'false',
    };

    // Show notification
    await self.registration.showNotification(title || 'WizCol', notificationOptions);
    
    // Notify clients if visible
    notifyClientsOfMessage(payload);
  });
} catch (err) {
  console.error('Firebase init failed in SW:', err);
}

// ==========================================
// Badge & Notification Helper Logic
// ==========================================

const notificationCache = new Map();
// Simple in-memory cache for now, or IndexedDB if needed for persistence across SW restarts
// The previous implementation used in-memory Map which dies if SW dies.
// We'll migrate to IDB for robustness if needed, but for now let's use the IDB logic for Badge Count at least.

async function saveNotificationToCache(id, data) {
    notificationCache.set(id, data);
}

// IndexedDB for Badges
const DB_NAME = 'FreeDiNotifications';
const BADGE_STORE = 'badgeCounter';

function openBadgeDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(BADGE_STORE)) {
        db.createObjectStore(BADGE_STORE, { keyPath: 'id' });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function getBadgeCount() {
  try {
    const db = await openBadgeDB();
    return new Promise((resolve) => {
        const tx = db.transaction(BADGE_STORE, 'readonly');
        const store = tx.objectStore(BADGE_STORE);
        const req = store.get('badge');
        req.onsuccess = () => resolve(req.result?.count || 0);
        req.onerror = () => resolve(0);
    });
  } catch (e) {
    return 0;
  }
}

async function setBadgeCount(count) {
  try {
    const db = await openBadgeDB();
    const tx = db.transaction(BADGE_STORE, 'readwrite');
    const store = tx.objectStore(BADGE_STORE);
    store.put({ id: 'badge', count });
    
    if (navigator.setAppBadge) {
        await navigator.setAppBadge(count);
    }
  } catch (e) {
    console.warn('Failed to set badge:', e);
  }
}

async function incrementBadgeCount() {
    // Check if any client is visible
    const clients = await self.clients.matchAll({ type: 'window', includeUncontrolled: true });
    const isAnyVisible = clients.some(c => c.visibilityState === 'visible' && c.focused);
    
    if (isAnyVisible) return; // Don't badge if watching

    const current = await getBadgeCount();
    await setBadgeCount(current + 1);
}

async function clearBadge() {
    await setBadgeCount(0);
    if (navigator.clearAppBadge) {
        navigator.clearAppBadge();
    }
}

async function notifyClientsOfMessage(payload) {
    const clients = await self.clients.matchAll({ type: 'window', includeUncontrolled: true });
    clients.forEach(client => {
        client.postMessage({
            type: 'NEW_NOTIFICATION_RECEIVED',
            payload
        });
    });
}

// ==========================================
// Event Listeners
// ==========================================

self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const data = event.notification.data || {};
  const url = data.url || '/';
  
  clearBadge();

  event.waitUntil((async () => {
    const clients = await self.clients.matchAll({ type: 'window', includeUncontrolled: true });
    // Try to focus existing
    for (const client of clients) {
      if (client.url.includes(url) || client.url === self.location.origin + '/') {
        await client.focus();
        client.postMessage({ type: 'NOTIFICATION_CLICKED', payload: data });
        return;
      }
    }
    // Open new
    await globalThis.clients.openWindow(url);
    // Note: postMessage to new client might fail if it's not ready, but we accept this risk or could retry
  })());
});

globalThis.addEventListener('message', (event) => {
    if (event.data?.type === 'SKIP_WAITING') {
        globalThis.skipWaiting();
    }
    if (event.data?.type === 'CLEAR_NOTIFICATIONS') {
        clearBadge();
    }
    if (event.data?.type === 'CHECK_PUSH_SUPPORT') {
        if (event.ports && event.ports[0]) {
			event.ports[0].postMessage({
				type: 'PUSH_SUPPORT_RESPONSE',
				supported: true,
				messaging: true,
				pushManager: 'PushManager' in self
			});
		}
    }
});