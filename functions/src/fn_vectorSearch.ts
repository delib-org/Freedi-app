import { logger } from "firebase-functions";
import { onCall, HttpsError, CallableRequest } from "firebase-functions/v2/https";
import { FieldValue, CollectionReference, Query } from "firebase-admin/firestore";
import { Collections, functionConfig, Statement } from "delib-npm";
import { db } from "./db";
import {
  generateEmbedding,
  getEmbeddingDimension,
} from "./services/vector-embedding-service";

/**
 * Vector Search Cloud Functions for Firestore
 *
 * These functions provide semantic similarity search capabilities using
 * Firestore's native vector search with embeddings generated by Gemini.
 *
 * Architecture:
 * 1. onStatementCreatedGenerateEmbedding - Firestore trigger that auto-generates
 *    embeddings when a statement is created
 * 2. findSimilarStatementsVector - Callable function for vector similarity search
 * 3. regenerateEmbedding - HTTP function to regenerate embedding for a statement
 */

// Types for vector search
interface SimilarStatementResult {
  id: string;
  statement: string;
  description?: string;
  distance: number;
  similarity: number;
}

interface FindSimilarRequest {
  text: string;
  parentId?: string;
  topParentId?: string;
  limit?: number;
  minSimilarity?: number;
}

interface FindSimilarResponse {
  ok: boolean;
  results: SimilarStatementResult[];
  queryEmbeddingDimension: number;
  searchTime: number;
}

/**
 * Combines statement and description into a single text for embedding
 * @param statement - The statement text
 * @param description - Optional description text
 * @returns Combined text for embedding generation
 */
function combineStatementText(statement: string, description?: string): string {
  if (!description || description.trim() === "") {
    return statement;
  }

  return `${statement}\n\n${description}`;
}

/**
 * Generates and stores embedding for a statement document
 * Called as part of statement creation process
 * @param statementId - The ID of the statement to embed
 * @param statementData - The statement document data
 */
export async function generateStatementEmbedding(
  statementId: string,
  statementData: Statement
): Promise<void> {
  const startTime = Date.now();

  try {
    const { statement, description } = statementData;

    if (!statement || statement.trim() === "") {
      logger.warn("Statement text is empty, skipping embedding", { statementId });

      return;
    }

    // Combine statement and description for better semantic representation
    const textToEmbed = combineStatementText(statement, description);

    logger.info("Generating embedding for statement", {
      statementId,
      textLength: textToEmbed.length,
    });

    // Generate embedding using Gemini
    const { embedding, dimension } = await generateEmbedding(textToEmbed);

    // Store embedding in Firestore using FieldValue.vector()
    const statementRef = db.collection(Collections.statements).doc(statementId);
    await statementRef.update({
      embedding: FieldValue.vector(embedding),
      embeddingDimension: dimension,
      embeddedAt: Date.now(),
    });

    const duration = Date.now() - startTime;
    logger.info("Embedding stored successfully", {
      statementId,
      dimension,
      duration,
    });
  } catch (error) {
    const duration = Date.now() - startTime;
    logger.error("Failed to generate embedding for statement", {
      statementId,
      error,
      duration,
    });
    // Don't throw - embedding failure shouldn't block statement creation
  }
}

/**
 * Callable function to find similar statements using Firestore vector search
 *
 * Usage from client:
 * ```typescript
 * const findSimilar = httpsCallable(functions, 'findSimilarStatementsVector');
 * const result = await findSimilar({
 *   text: "user's input text",
 *   parentId: "optional-question-id",
 *   limit: 5
 * });
 * ```
 */
export const findSimilarStatementsVector = onCall(
  {
    ...functionConfig,
    cors: true,
  },
  async (request: CallableRequest<FindSimilarRequest>): Promise<FindSimilarResponse> => {
    const startTime = Date.now();

    try {
      const {
        text,
        parentId,
        topParentId,
        limit = 5,
        minSimilarity = 0.6,
      } = request.data;

      // Validate input
      if (!text || typeof text !== "string" || text.trim() === "") {
        throw new HttpsError("invalid-argument", "Text parameter is required");
      }

      if (limit < 1 || limit > 20) {
        throw new HttpsError(
          "invalid-argument",
          "Limit must be between 1 and 20"
        );
      }

      logger.info("Finding similar statements", {
        textLength: text.length,
        parentId,
        topParentId,
        limit,
      });

      // Generate embedding for the query text
      const { embedding: queryEmbedding, dimension } =
        await generateEmbedding(text);

      // Build the base query
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      let query: CollectionReference | Query = db.collection(Collections.statements);

      // Apply filters if provided
      // Note: Firestore vector search requires pre-filtering before findNearest
      if (parentId) {
        query = query.where("parentId", "==", parentId);
      } else if (topParentId) {
        query = query.where("topParentId", "==", topParentId);
      }

      // Perform vector similarity search using Firestore's findNearest
      // This requires a vector index to be created on the 'embedding' field
      const vectorQuery = query.findNearest({
        vectorField: "embedding",
        queryVector: queryEmbedding,
        limit: limit,
        distanceMeasure: "COSINE",
      });

      const snapshot = await vectorQuery.get();

      // Process results and calculate similarity scores
      const results: SimilarStatementResult[] = [];

      snapshot.docs.forEach((doc) => {
        const data = doc.data();
        // Firestore returns distance, convert to similarity (1 - distance for cosine)
        const distance = data.vector_distance ?? 0;
        const similarity = 1 - distance;

        // Filter by minimum similarity threshold
        if (similarity >= minSimilarity) {
          results.push({
            id: doc.id,
            statement: data.statement,
            description: data.description,
            distance,
            similarity,
          });
        }
      });

      const searchTime = Date.now() - startTime;
      logger.info("Vector search completed", {
        resultsCount: results.length,
        searchTime,
        dimension,
      });

      return {
        ok: true,
        results,
        queryEmbeddingDimension: dimension,
        searchTime,
      };
    } catch (error) {
      const searchTime = Date.now() - startTime;
      logger.error("Error in findSimilarStatementsVector", {
        error,
        searchTime,
      });

      if (error instanceof HttpsError) {
        throw error;
      }

      throw new HttpsError(
        "internal",
        "Failed to perform vector search",
        error
      );
    }
  }
);

/**
 * Regenerate embedding for an existing statement
 * Useful for batch updates or when embedding model changes
 */
export async function regenerateStatementEmbedding(
  statementId: string
): Promise<void> {
  try {
    const statementRef = db.collection(Collections.statements).doc(statementId);
    const statementDoc = await statementRef.get();

    if (!statementDoc.exists) {
      logger.error("Statement not found for embedding regeneration", {
        statementId,
      });

      return;
    }

    const statementData = statementDoc.data() as Statement;
    await generateStatementEmbedding(statementId, statementData);

    logger.info("Embedding regenerated successfully", { statementId });
  } catch (error) {
    logger.error("Failed to regenerate embedding", { statementId, error });
    throw error;
  }
}

/**
 * Batch regenerate embeddings for multiple statements
 * Useful for initial migration or model updates
 * @param statementIds - Array of statement IDs to regenerate embeddings for
 * @param concurrency - Number of parallel operations (default: 5)
 */
export async function batchRegenerateEmbeddings(
  statementIds: string[],
  concurrency = 5
): Promise<{ success: number; failed: number }> {
  logger.info("Starting batch embedding regeneration", {
    count: statementIds.length,
    concurrency,
  });

  let success = 0;
  let failed = 0;

  // Process in batches with concurrency limit
  for (let i = 0; i < statementIds.length; i += concurrency) {
    const batch = statementIds.slice(i, i + concurrency);
    const results = await Promise.allSettled(
      batch.map((id) => regenerateStatementEmbedding(id))
    );

    results.forEach((result) => {
      if (result.status === "fulfilled") {
        success++;
      } else {
        failed++;
      }
    });

    logger.info("Batch progress", {
      processed: Math.min(i + concurrency, statementIds.length),
      total: statementIds.length,
      success,
      failed,
    });
  }

  logger.info("Batch embedding regeneration completed", { success, failed });

  return { success, failed };
}

/**
 * Get embedding status for a statement
 */
export async function getEmbeddingStatus(
  statementId: string
): Promise<{
  hasEmbedding: boolean;
  dimension?: number;
  embeddedAt?: number;
}> {
  const statementRef = db.collection(Collections.statements).doc(statementId);
  const statementDoc = await statementRef.get();

  if (!statementDoc.exists) {
    return { hasEmbedding: false };
  }

  const data = statementDoc.data();
  const hasEmbedding = !!data?.embedding;

  return {
    hasEmbedding,
    dimension: data?.embeddingDimension,
    embeddedAt: data?.embeddedAt,
  };
}

/**
 * Export embedding dimension for index creation reference
 */
export { getEmbeddingDimension };
